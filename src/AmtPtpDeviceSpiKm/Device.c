/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, AmtPtpDeviceSpiKmCreateDevice)
#endif

NTSTATUS
AmtPtpDeviceSpiKmCreateDevice(
    _Inout_ PWDFDEVICE_INIT DeviceInit
    )
/*++

Routine Description:

    Worker routine called to create a device and its software resources.

Arguments:

    DeviceInit - Pointer to an opaque init structure. Memory for this
                    structure will be freed by the framework when the WdfDeviceCreate
                    succeeds. So don't access the structure after that point.

Return Value:

    NTSTATUS

--*/
{
    WDF_OBJECT_ATTRIBUTES DeviceAttributes;
    PDEVICE_CONTEXT pDeviceContext;
    WDFDEVICE Device;
    NTSTATUS Status;

	WDF_PNPPOWER_EVENT_CALLBACKS pnpPowerCallbacks;

    PAGED_CODE();

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Entry"
	);

	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "AmtPtpDeviceSpiKmCreateDevice Entry \n"));

	// Initialize Power Callback
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

	// Initialize PNP power event callbacks
	pnpPowerCallbacks.EvtDevicePrepareHardware = AmtPtpEvtDevicePrepareHardware;
	pnpPowerCallbacks.EvtDeviceD0Entry = AmtPtpEvtDeviceD0Entry;
	pnpPowerCallbacks.EvtDeviceD0Exit = AmtPtpEvtDeviceD0Exit;
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	// Create WDF device object
    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&DeviceAttributes, DEVICE_CONTEXT);

    Status = WdfDeviceCreate(&DeviceInit, &DeviceAttributes, &Device);

    if (NT_SUCCESS(Status)) 
	{
        //
        // Get a pointer to the device context structure that we just associated
        // with the device object. We define this structure in the device.h
        // header file. DeviceGetContext is an inline function generated by
        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
        // This function will do the type checking and return the device context.
        // If you pass a wrong object handle it will return NULL and assert if
        // run under framework verifier mode.
        //
        pDeviceContext = DeviceGetContext(Device);

		//
		// Put itself in
		//
		pDeviceContext->SpiDevice = Device;
		pDeviceContext->DelayedRequest = FALSE;

		//
		// Retrieve IO target.
		//
		pDeviceContext->SpiTrackpadIoTarget = WdfDeviceGetIoTarget(Device);
		if (pDeviceContext->SpiTrackpadIoTarget == NULL) 
		{
			Status = STATUS_INVALID_DEVICE_STATE;
			goto exit;
		}

		//
		// Initialize kernel event.
		//
		KeInitializeEvent(
			&pDeviceContext->PtpRequestRoutineEvent, 
			NotificationEvent, 
			TRUE
		);

		KeInitializeEvent(
			&pDeviceContext->PtpLoopRoutineEvent,
			NotificationEvent,
			TRUE
		);

		//
		// Initialize buffer.
		//
		Status = WdfMemoryCreate(
			WDF_NO_OBJECT_ATTRIBUTES,
			NonPagedPool,
			PTP_POOL_TAG,
			REPORT_BUFFER_SIZE,
			&pDeviceContext->SpiHidReadBuffer,
			NULL
		);

		if (!NT_SUCCESS(Status))
		{
			goto exit;
		}

        //
        // Create a device interface so that applications can find and talk
        // to us.
        //
        Status = WdfDeviceCreateDeviceInterface(
            Device,
            &GUID_DEVINTERFACE_AmtPtpDeviceSpiKm,
            NULL // ReferenceString
        );

        if (NT_SUCCESS(Status)) 
		{
            //
            // Initialize the I/O Package and any Queues
            //
            Status = AmtPtpDeviceSpiKmQueueInitialize(Device);
        }
    }

exit:
	KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "AmtPtpDeviceSpiKmCreateDevice Exit \n"));

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

    return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDevicePrepareHardware(
	_In_ WDFDEVICE Device,
	_In_ WDFCMRESLIST ResourceList,
	_In_ WDFCMRESLIST ResourceListTranslated
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;

	WDF_MEMORY_DESCRIPTOR HidAttributeMemoryDescriptor;
	HID_DEVICE_ATTRIBUTES DeviceAttributes;

	PAGED_CODE();
	UNREFERENCED_PARAMETER(ResourceList);
	UNREFERENCED_PARAMETER(ResourceListTranslated);

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Entry"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDevicePrepareHardware entry \n"
	));

	pDeviceContext = DeviceGetContext(Device);
	if (pDeviceContext == NULL)
	{
		Status = STATUS_INVALID_DEVICE_STATE;
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! pDeviceContext == NULL"
		);

		goto exit;
	}

	// Request device attribute descriptor for self-identification.
	WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(
		&HidAttributeMemoryDescriptor,
		(PVOID) &DeviceAttributes,
		sizeof(DeviceAttributes)
	);

	Status = WdfIoTargetSendInternalIoctlSynchronously(
		pDeviceContext->SpiTrackpadIoTarget,
		NULL,
		IOCTL_HID_GET_DEVICE_ATTRIBUTES,
		NULL,
		&HidAttributeMemoryDescriptor,
		NULL,
		NULL
	);

	if (!NT_SUCCESS(Status))
	{
		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"WdfIoTargetSendInternalIoctlSynchronously failed, status = 0x%x \n",
			Status
		));

		goto exit;
	}

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"Device Vendor ID: 0x%x, Product ID: 0x%x, Version: 0x%x \n",
		DeviceAttributes.VendorID,
		DeviceAttributes.ProductID,
		DeviceAttributes.VersionNumber
	));

	pDeviceContext->HidVendorID = DeviceAttributes.VendorID;
	pDeviceContext->HidProductID = DeviceAttributes.ProductID;
	pDeviceContext->HidVersionNumber = DeviceAttributes.VersionNumber;

exit:
	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDevicePrepareHardware exit, status = 0x%x \n",
		Status
	));

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDeviceD0Entry(
	_In_ WDFDEVICE Device,
	_In_ WDF_POWER_DEVICE_STATE PreviousState
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;

	PAGED_CODE();

	// Log status
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! -->AmtPtpDeviceEvtDeviceD0Entry - coming from %s",
		DbgDevicePowerString(PreviousState)
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL, 
		"AmtPtpEvtDeviceD0Entry -->AmtPtpDeviceEvtDeviceD0Entry - coming from %s \n", 
		DbgDevicePowerString(PreviousState)
	));

	pDeviceContext = DeviceGetContext(Device);

	// Enable SPI trackpad
	Status = AmtPtpSpiSetState(
		Device,
		TRUE
	);

	if (!NT_SUCCESS(Status))
	{
		goto exit;
	}

	// Set flag
	pDeviceContext->DeviceReady = TRUE;

	// Set time
	KeQueryPerformanceCounter(
		&pDeviceContext->LastReportTime
	);

	// Start HID loop in a new thread
	Status = PsCreateSystemThread(
		&pDeviceContext->InputPollThreadHandle,
		(ACCESS_MASK)0,
		NULL,
		(HANDLE)0,
		NULL,
		AmtPtpSpiInputThreadRoutine,
		pDeviceContext
	);

	if (!NT_SUCCESS(Status))
	{
		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"PsCreateSystemThread failed, status = 0x%x \n",
			Status
		));
	}

exit:
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! <-- AmtPtpDeviceEvtDeviceD0Entry"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Entry <-- AmtPtpDeviceEvtDeviceD0Entry \n"
	));

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpEvtDeviceD0Exit(
	_In_ WDFDEVICE Device,
	_In_ WDF_POWER_DEVICE_STATE TargetState
)
{
	NTSTATUS Status = STATUS_SUCCESS;
	PDEVICE_CONTEXT pDeviceContext;
	WDFREQUEST RemainingRequest;

	PAGED_CODE();

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! -->AmtPtpDeviceEvtDeviceD0Exit - moving to %s",
		DbgDevicePowerString(TargetState)
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Exit -->AmtPtpDeviceEvtDeviceD0Exit - moving to %s \n",
		DbgDevicePowerString(TargetState)
	));

	pDeviceContext = DeviceGetContext(Device);

	// Set flag & it will stop HID read loop thread
	pDeviceContext->DeviceReady = FALSE;

	// Cancel current device request
	if (pDeviceContext->PendingRequest)
	{
		WdfRequestCancelSentRequest(
			pDeviceContext->SpiHidReadRequest
		);
	}

	// Wait for signaled state
	KeWaitForSingleObject(
		&pDeviceContext->PtpRequestRoutineEvent,
		Executive,
		KernelMode,
		FALSE,
		NULL
	);

	KeWaitForSingleObject(
		&pDeviceContext->PtpLoopRoutineEvent,
		Executive,
		KernelMode,
		FALSE,
		NULL
	);

	// Clean outstanding requests
	while (Status == STATUS_SUCCESS)
	{
		Status = WdfIoQueueRetrieveNextRequest(
			pDeviceContext->HidIoQueue,
			&RemainingRequest
		);

		if (NT_SUCCESS(Status))
		{
			WdfRequestComplete(
				RemainingRequest,
				STATUS_CANCELLED
			);
		}
	}

	// Disable HID trackpad
	Status = AmtPtpSpiSetState(
		Device,
		FALSE
	);

	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! <--AmtPtpDeviceEvtDeviceD0Exit"
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpEvtDeviceD0Exit <-- AmtPtpDeviceEvtDeviceD0Exit Exit \n"
	));

	return Status;
}

_IRQL_requires_(PASSIVE_LEVEL)
PCHAR
DbgDevicePowerString(
	_In_ WDF_POWER_DEVICE_STATE Type
)
{
	switch (Type)
	{
	case WdfPowerDeviceInvalid:
		return "WdfPowerDeviceInvalid";
	case WdfPowerDeviceD0:
		return "WdfPowerDeviceD0";
	case WdfPowerDeviceD1:
		return "WdfPowerDeviceD1";
	case WdfPowerDeviceD2:
		return "WdfPowerDeviceD2";
	case WdfPowerDeviceD3:
		return "WdfPowerDeviceD3";
	case WdfPowerDeviceD3Final:
		return "WdfPowerDeviceD3Final";
	case WdfPowerDevicePrepareForHibernation:
		return "WdfPowerDevicePrepareForHibernation";
	case WdfPowerDeviceMaximum:
		return "WdfPowerDeviceMaximum";
	default:
		return "UnKnown Device Power State";
	}
}

_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
AmtPtpSpiSetState(
	_In_ WDFDEVICE Device,
	_In_ BOOLEAN DesiredState
)
{
	NTSTATUS Status;
	PDEVICE_CONTEXT pDeviceContext;
	UCHAR HidPacketBuffer[HID_XFER_PACKET_SIZE];
	WDF_MEMORY_DESCRIPTOR HidMemoryDescriptor;
	PHID_XFER_PACKET pHidPacket;
	PSPI_SET_FEATURE pSpiSetStatus;

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiSetState Entry \n"
	));

	pDeviceContext = DeviceGetContext(Device);
	if (pDeviceContext == NULL)
	{
		Status = STATUS_INVALID_DEVICE_STATE;
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! pDeviceContext == NULL"
		);

		goto exit;
	}

	pHidPacket = (PHID_XFER_PACKET) &HidPacketBuffer;

	WDF_MEMORY_DESCRIPTOR_INIT_BUFFER(
		&HidMemoryDescriptor,
		(PVOID) &HidPacketBuffer,
		HID_XFER_PACKET_SIZE
	);

	pHidPacket->reportId = HID_REPORTID_MOUSE;
	pHidPacket->reportBufferLen = sizeof(SPI_SET_FEATURE);
	pHidPacket->reportBuffer = (PUCHAR) pHidPacket + sizeof(HID_XFER_PACKET);
	pSpiSetStatus = (PSPI_SET_FEATURE) pHidPacket->reportBuffer;

	// SPI Bus, location 2
	pSpiSetStatus->BusLocation = 2;
	pSpiSetStatus->Status = DesiredState ? 1 : 0;

	// Will non-internal IOCTL work?
	Status = WdfIoTargetSendInternalIoctlSynchronously(
		pDeviceContext->SpiTrackpadIoTarget,
		NULL,
		IOCTL_HID_SET_FEATURE,
		&HidMemoryDescriptor,
		NULL,
		NULL,
		NULL
	);

	if (!NT_SUCCESS(Status))
	{
		TraceEvents(
			TRACE_LEVEL_ERROR,
			TRACE_DRIVER,
			"%!FUNC! WdfIoTargetSendIoctlSynchronously failed with %!STATUS!",
			Status
		);

		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"WdfIoTargetSendIoctlSynchronously failed \n"
		));
	}
	else
	{
		TraceEvents(
			TRACE_LEVEL_INFORMATION,
			TRACE_DRIVER,
			"%!FUNC! Changed trackpad status to %d",
			DesiredState
		);

		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"AmtPtpSpiSetState Changed trackpad status to %d \n",
			DesiredState
		));
	}

exit:
	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiSetState Exit \n"
	));
	TraceEvents(
		TRACE_LEVEL_INFORMATION,
		TRACE_DRIVER,
		"%!FUNC! Exit, Status = %!STATUS!",
		Status
	);

	return Status;
}

void
AmtPtpSpiInputThreadRoutine(
	PVOID StartContext
)
{
	PDEVICE_CONTEXT pDeviceContext;
	LARGE_INTEGER WaitInterval;

	PAGED_CODE();

	// Sanity check for the thing
	if (StartContext == NULL) return;
	pDeviceContext = (PDEVICE_CONTEXT) StartContext;

	// Lock it up!
	KeClearEvent(
		&pDeviceContext->PtpLoopRoutineEvent
	);

	// Initialize wait interval
	WaitInterval.QuadPart = WDF_REL_TIMEOUT_IN_MS(100);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiInputThreadRoutine: ready to loop. \n"
	));

	while (pDeviceContext->DeviceReady)
	{
		if (pDeviceContext->DelayedRequest)
		{
			pDeviceContext->DelayedRequest = FALSE;

			// Delayed request: Pass it to the worker.
			AmtPtpSpiInputRoutineWorker(pDeviceContext->SpiDevice);
		}
		
		KeDelayExecutionThread(KernelMode, FALSE, &WaitInterval);

		KdPrintEx((
			DPFLTR_IHVDRIVER_ID,
			DPFLTR_INFO_LEVEL,
			"AmtPtpSpiInputThreadRoutine: loop routine. \n"
		));
	}

	// Notify that we are safe to terminate
	KeSetEvent(
		&pDeviceContext->PtpLoopRoutineEvent,
		0,
		FALSE
	);

	KdPrintEx((
		DPFLTR_IHVDRIVER_ID,
		DPFLTR_INFO_LEVEL,
		"AmtPtpSpiInputThreadRoutine: terminated. \n"
	));

	// Goodbye
	PsTerminateSystemThread(STATUS_SUCCESS);
}
